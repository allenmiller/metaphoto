service: metaphoto-time

provider:
  name: aws
  runtime: nodejs10.x
  stage: dev
  region: us-west-2
  deploymentBucket: ${cf:metaphoto-us-west-2-dev.MetaphotoPipelineArtifactsBucket}
  dataBucket: ${cf:metaphoto-us-west-2-dev.MetaphotoDataBucket}
  domain: ${cf:metaphoto-us-west-2-dev.MetaphotoHostedZone}
  certificateArn: ${cf:metaphoto-us-west-2-dev.MetaphotoCertificateArn}

plugins:
  - serverless-domain-manager

custom:
  stage: ${opt:stage, self:provider.stage}

  # Important: The Route53 A and AAAA domain records created by serverless-domain-manager are managed by the API,
  # not Cloudformation.  They do not appear as Resources in the Cloudformation stack for this service.  Do not manage
  # them manually via Route53.
  #
  # When deleting this stack, do 'sls delete_domain', then 'sls remove'.  Failure to do this may result in lost, hidden
  # custom domains which will cause certificates to be un-removable.  See:
  # https://forum.serverless.com/t/solved-cannot-delete-certificate-cloudfront-distribution-not-showing/3792/4
  #
  # TL;DR: if this happens, create a temporary API gateway so you can see the Custom Domain Names and delete it manually.
  #
  # TODO: create a pipeline action to automate this cleanup

  customDomain:
    domainName: api.${self:provider.domain}
    stage: ${self:provider.stage}
    basePath: ${self:provider.stage}
    certificateArn: ${self:provider.certificateArn}
    endpointType: REGIONAL
    createRoute53Record: true

functions:
  get:
    handler: time.handler
    events:
      - http:
          path: time
          method: get
          cors: true
          authorizer: aws_iam

resources:
  Resources:
    CognitoUserPool:
      Type: AWS::Cognito::UserPool
      Properties:
        # Generate a name based on the stage
        UserPoolName: ${self:custom.stage}-metaphoto-user-pool
        # Set email as an alias
        UsernameAttributes:
          - email
        AutoVerifiedAttributes:
          - email

    CognitoUserPoolClient:
      Type: AWS::Cognito::UserPoolClient
      Properties:
        # Generate an app client name based on the stage
        ClientName: ${self:custom.stage}-metaphoto-user-pool-client
        UserPoolId:
          Ref: CognitoUserPool
        ExplicitAuthFlows:
          - ADMIN_NO_SRP_AUTH
        GenerateSecret: false

    # The federated identity for our user pool to auth with
    CognitoIdentityPool:
      Type: AWS::Cognito::IdentityPool
      Properties:
        # Generate a name based on the stage
        IdentityPoolName: ${self:custom.stage}MetaphotoIdentityPool
        # Don't allow unathenticated users
        AllowUnauthenticatedIdentities: false
        # Link to our User Pool
        CognitoIdentityProviders:
          - ClientId:
              Ref: CognitoUserPoolClient
            ProviderName:
              Fn::GetAtt: [ "CognitoUserPool", "ProviderName" ]

    # IAM roles
    CognitoIdentityPoolRoles:
      Type: AWS::Cognito::IdentityPoolRoleAttachment
      Properties:
        IdentityPoolId:
          Ref: CognitoIdentityPool
        Roles:
          authenticated:
            Fn::GetAtt: [CognitoAuthRole, Arn]

    # IAM role used for authenticated users
    CognitoAuthRole:
      Type: AWS::IAM::Role
      Properties:
        Path: /
        AssumeRolePolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: 'Allow'
              Principal:
                Federated: 'cognito-identity.amazonaws.com'
              Action:
                - 'sts:AssumeRoleWithWebIdentity'
              Condition:
                StringEquals:
                  'cognito-identity.amazonaws.com:aud':
                    Ref: CognitoIdentityPool
                'ForAnyValue:StringLike':
                  'cognito-identity.amazonaws.com:amr': authenticated
        Policies:
          - PolicyName: 'CognitoAuthorizedPolicy'
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: 'Allow'
                  Action:
                    - 'cognito-sync:*'
                    - 'cognito-identity:*'
                  Resource: '*'

                # Allow users to invoke our API
                - Effect: 'Allow'
                  Action:
                    - 'execute-api:Invoke'
                  Resource:
                    Fn::Join:
                      - ''
                      -
                        - 'arn:aws:execute-api:'
                        - Ref: AWS::Region
                        - ':'
                        - Ref: AWS::AccountId
                        - ':'
                        - ApiGatewayRestApiId
                        - '/*'

                # Allow users to upload attachments to their
                # folder inside our S3 bucket
                - Effect: 'Allow'
                  Action:
                    - 's3:*'
                  Resource:
                    - Fn::Join:
                        - ''
                        -
                          - 'arn:aws:s3:::'
                          - ${self:provider.deploymentBucket}
                          - '/private/*'
                          #TODO: figure out substitution to specify user-specific keys

  # Print out the Id of the User Pool and Identity Pool that are created
  Outputs:
    UserPoolId:
      Value:
        Ref: CognitoUserPool

    UserPoolClientId:
      Value:
        Ref: CognitoUserPoolClient

    IdentityPoolId:
      Value:
        Ref: CognitoIdentityPool
